// Code generated by Icestudio 0.5.1n201009

`default_nettype none

module main #(
 parameter vd4ee6a = 1,
 parameter v403345 = "v403345.list",
 parameter v5f11ac = "v5f11ac.list",
 parameter v037380 = "v037380.list",
 parameter v3b5da9 = "v3b5da9.list",
 parameter v09e9cd = 1,
 parameter vf0ced6 = 0,
 parameter v2ad907 = "v2ad907.list",
 parameter vaccff2 = "vaccff2.list",
 parameter v9446c3 = "v9446c3.list",
 parameter v8e7575 = "v8e7575.list",
 parameter v7d7c21 = "v7d7c21.list",
 parameter v0bd81d = "v0bd81d.list",
 parameter v9281a0 = "v9281a0.list",
 parameter vaf68f5 = "vaf68f5.list",
 parameter vf95e91 = "vf95e91.list",
 parameter vf42cae = "vf42cae.list",
 parameter v878068 = "v878068.list",
 parameter v9518f5 = "v9518f5.list",
 parameter v910ea9 = "v910ea9.list",
 parameter v9a6f4a = "v9a6f4a.list",
 parameter v540f14 = "v540f14.list",
 parameter v65422b = "v65422b.list",
 parameter v33c845 = "v33c845.list",
 parameter v8d2f5c = "v8d2f5c.list"
) (
 input vaac680,
 input v5c5be6,
 input v5829e0,
 input vclk,
 output [2:0] v2baa74,
 output [7:0] va19889,
 output v255f3f,
 output va7d72c,
 output v13dab4
);
 localparam p5 = v9a6f4a;
 localparam p11 = v8d2f5c;
 localparam p17 = v09e9cd;
 localparam p22 = vf0ced6;
 localparam p34 = v8e7575;
 localparam p35 = v2ad907;
 localparam p38 = vd4ee6a;
 localparam p65 = v403345;
 wire w0;
 wire [0:6] w1;
 wire [0:1] w2;
 wire w3;
 wire [0:16] w4;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:16] w12;
 wire [0:16] w13;
 wire [0:7] w14;
 wire w15;
 wire w16;
 wire w18;
 wire w19;
 wire [0:9] w20;
 wire w21;
 wire [0:16] w23;
 wire [0:34] w24;
 wire w25;
 wire w26;
 wire [0:34] w27;
 wire w28;
 wire [0:7] w29;
 wire w30;
 wire w31;
 wire w32;
 wire [0:2] w33;
 wire [0:9] w36;
 wire [0:9] w37;
 wire [0:9] w39;
 wire w40;
 wire w41;
 wire w42;
 wire w43;
 wire w44;
 wire w45;
 wire w46;
 wire w47;
 wire w48;
 wire w49;
 wire w50;
 wire w51;
 wire w52;
 wire [0:15] w53;
 wire [0:7] w54;
 wire [0:16] w55;
 wire [0:16] w56;
 wire w57;
 wire [0:7] w58;
 wire [0:34] w59;
 wire w60;
 wire [0:7] w61;
 wire [0:7] w62;
 wire [0:7] w63;
 wire [0:6] w64;
 wire [0:2] w66;
 wire [0:7] w67;
 wire w68;
 wire w69;
 wire w70;
 wire w71;
 wire w72;
 wire w73;
 wire w74;
 wire w75;
 wire w76;
 wire w77;
 wire w78;
 wire w79;
 wire w80;
 wire [0:9] w81;
 wire [0:9] w82;
 wire [0:9] w83;
 wire w84;
 wire [0:4] w85;
 wire w86;
 wire w87;
 wire w88;
 wire w89;
 wire w90;
 wire [0:16] w91;
 wire [0:16] w92;
 wire [0:16] w93;
 wire [0:16] w94;
 wire [0:16] w95;
 wire [0:16] w96;
 wire [0:16] w97;
 wire [0:16] w98;
 wire [0:16] w99;
 wire w100;
 wire w101;
 wire w102;
 wire w103;
 wire w104;
 wire w105;
 wire w106;
 wire [0:9] w107;
 wire w108;
 wire w109;
 wire w110;
 wire w111;
 wire w112;
 wire w113;
 wire w114;
 wire w115;
 wire [0:16] w116;
 wire [0:4] w117;
 wire w118;
 wire w119;
 wire w120;
 wire w121;
 wire w122;
 wire w123;
 wire [0:4] w124;
 wire w125;
 wire w126;
 wire w127;
 wire w128;
 wire w129;
 wire w130;
 wire w131;
 wire w132;
 wire w133;
 wire w134;
 wire w135;
 assign w0 = v5829e0;
 assign w3 = vaac680;
 assign v255f3f = w28;
 assign v2baa74 = w33;
 assign w52 = v5c5be6;
 assign va19889 = w62;
 assign w68 = vclk;
 assign w69 = vclk;
 assign w70 = vclk;
 assign w71 = vclk;
 assign w72 = vclk;
 assign w73 = vclk;
 assign w74 = vclk;
 assign w75 = vclk;
 assign w76 = vclk;
 assign w77 = vclk;
 assign w78 = vclk;
 assign w79 = vclk;
 assign w80 = vclk;
 assign v13dab4 = w119;
 assign va7d72c = w134;
 assign w46 = w41;
 assign w59 = w24;
 assign w60 = w26;
 assign w69 = w68;
 assign w70 = w68;
 assign w70 = w69;
 assign w71 = w68;
 assign w71 = w69;
 assign w71 = w70;
 assign w72 = w68;
 assign w72 = w69;
 assign w72 = w70;
 assign w72 = w71;
 assign w73 = w68;
 assign w73 = w69;
 assign w73 = w70;
 assign w73 = w71;
 assign w73 = w72;
 assign w74 = w68;
 assign w74 = w69;
 assign w74 = w70;
 assign w74 = w71;
 assign w74 = w72;
 assign w74 = w73;
 assign w75 = w68;
 assign w75 = w69;
 assign w75 = w70;
 assign w75 = w71;
 assign w75 = w72;
 assign w75 = w73;
 assign w75 = w74;
 assign w76 = w68;
 assign w76 = w69;
 assign w76 = w70;
 assign w76 = w71;
 assign w76 = w72;
 assign w76 = w73;
 assign w76 = w74;
 assign w76 = w75;
 assign w77 = w68;
 assign w77 = w69;
 assign w77 = w70;
 assign w77 = w71;
 assign w77 = w72;
 assign w77 = w73;
 assign w77 = w74;
 assign w77 = w75;
 assign w77 = w76;
 assign w78 = w68;
 assign w78 = w69;
 assign w78 = w70;
 assign w78 = w71;
 assign w78 = w72;
 assign w78 = w73;
 assign w78 = w74;
 assign w78 = w75;
 assign w78 = w76;
 assign w78 = w77;
 assign w79 = w68;
 assign w79 = w69;
 assign w79 = w70;
 assign w79 = w71;
 assign w79 = w72;
 assign w79 = w73;
 assign w79 = w74;
 assign w79 = w75;
 assign w79 = w76;
 assign w79 = w77;
 assign w79 = w78;
 assign w80 = w68;
 assign w80 = w69;
 assign w80 = w70;
 assign w80 = w71;
 assign w80 = w72;
 assign w80 = w73;
 assign w80 = w74;
 assign w80 = w75;
 assign w80 = w76;
 assign w80 = w77;
 assign w80 = w78;
 assign w80 = w79;
 assign w82 = w81;
 assign w83 = w81;
 assign w83 = w82;
 assign w87 = w86;
 assign w88 = w86;
 assign w88 = w87;
 assign w89 = w86;
 assign w89 = w87;
 assign w89 = w88;
 assign w90 = w86;
 assign w90 = w87;
 assign w90 = w88;
 assign w90 = w89;
 assign w92 = w91;
 assign w93 = w91;
 assign w93 = w92;
 assign w94 = w91;
 assign w94 = w92;
 assign w94 = w93;
 assign w95 = w91;
 assign w95 = w92;
 assign w95 = w93;
 assign w95 = w94;
 assign w97 = w96;
 assign w98 = w96;
 assign w98 = w97;
 assign w99 = w96;
 assign w99 = w97;
 assign w99 = w98;
 assign w101 = w100;
 assign w102 = w100;
 assign w102 = w101;
 assign w103 = w100;
 assign w103 = w101;
 assign w103 = w102;
 assign w104 = w100;
 assign w104 = w101;
 assign w104 = w102;
 assign w104 = w103;
 assign w105 = w100;
 assign w105 = w101;
 assign w105 = w102;
 assign w105 = w103;
 assign w105 = w104;
 assign w106 = w100;
 assign w106 = w101;
 assign w106 = w102;
 assign w106 = w103;
 assign w106 = w104;
 assign w106 = w105;
 assign w107 = w36;
 assign w112 = w111;
 assign w116 = w55;
 assign w119 = w118;
 assign w123 = w122;
 assign w130 = w129;
 assign w131 = w129;
 assign w131 = w130;
 assign w132 = w129;
 assign w132 = w130;
 assign w132 = w131;
 v2107ac v331c5c (
  .vd9601b(w0),
  .vbbbce8(w68),
  .v64879c(w128)
 );
 ve79148 vcc45af (
  .vd76104(w2),
  .vdd729a(w69),
  .v712cd1(w84),
  .ve61673(w90),
  .v7c533e(w106)
 );
 ve216c9 vc2366c (
  .v1a0366(w1),
  .v4566f6(w2),
  .vd2cdbd(w85)
 );
 vb2090f v39bd9d (
  .vcbab45(w6),
  .v0e28cb(w128),
  .v3ca442(w129)
 );
 v2107ac va3154c (
  .vd9601b(w3),
  .v157a67(w32),
  .vbbbce8(w70)
 );
 v5fb041 v73f166 (
  .v26bf15(w4),
  .va470fb(w81),
  .vf72a5a(w85)
 );
 vf7a5f1 ve5ee86 (
  .v67d667(w4),
  .vf892a0(w7),
  .ve1f7e8(w8),
  .v41eb95(w71),
  .va943c0(w91)
 );
 v3e1356 vbb4915 (
  .vd25e4b(w20),
  .v10ee83(w36),
  .v3e30ba(w82),
  .v50d6c6(w110)
 );
 v5fb041 v0bd638 (
  .v26bf15(w95),
  .vf72a5a(w117)
 );
 vb2090f v3014ee (
  .vcbab45(w40),
  .v0e28cb(w101),
  .v3ca442(w112)
 );
 vbc6704 v9f97a1 (
  .v595263(w14),
  .v2c9812(w108),
  .v7ada3f(w110),
  .ve0c1b4(w111),
  .vc85478(w122),
  .v7c37b3(w125),
  .v8f149e(w129),
  .vb85197(w134),
  .v45ab8c(w135)
 );
 v5cc6ec vcae5c3 (
  .vb186da(w6),
  .v381ebf(w9),
  .vc93bbe(w100),
  .v50d6c6(w135)
 );
 vb2090f v19ad5f (
  .vcbab45(w31),
  .v3ca442(w103),
  .v0e28cb(w122)
 );
 vb2090f vbf0abd (
  .vcbab45(w7),
  .v0e28cb(w100),
  .v3ca442(w108)
 );
 v816138 v62c882 (
  .vcbab45(w8),
  .v0e28cb(w84),
  .v3ca442(w86)
 );
 v3db97e v009889 (
  .v6d0651(w15),
  .v4c8225(w72)
 );
 v816138 v6ebed9 (
  .v0e28cb(w18),
  .v3ca442(w32),
  .vcbab45(w86)
 );
 vb2090f vde9c19 (
  .vcbab45(w10),
  .v0e28cb(w121),
  .v3ca442(w130)
 );
 v5cc6ec v127a23 (
  .vc93bbe(w9),
  .vb186da(w10),
  .v381ebf(w50),
  .v50d6c6(w123)
 );
 v35f267 v17d3e9 (
  .v0e28cb(w30),
  .vcbab45(w121)
 );
 v4afab0 #(
  .vb36a78(p11)
 ) v2f9bf8 (
  .vfde47f(w29),
  .v851180(w117)
 );
 v441629 vd70bc2 (
  .v69b4d1(w12),
  .vb2c62c(w19),
  .v41eb95(w73),
  .v787077(w96),
  .vf892a0(w114)
 );
 v3369ab v56ee48 (
  .v02a59a(w13),
  .va79ab3(w92),
  .vcedc5d(w97)
 );
 ve605e8 v861ded (
  .v516280(w12),
  .v5f8230(w13),
  .v6fb6f4(w94),
  .v50d6c6(w115)
 );
 va3eeb4 va0b8c9 (
  .v0e9841(w62),
  .v26bf15(w96)
 );
 v43b132 vf3feca (
  .v738343(w33)
 );
 v42ebf7 #(
  .v71e305(p17)
 ) vbb0271 (
  .v9afc1f(w15),
  .vf54559(w16),
  .ve8318d(w18),
  .va4102a(w74)
 );
 v21cfcc vd2c5f7 (
  .v9fb85f(w16)
 );
 vb2090f v9533cd (
  .vcbab45(w26),
  .v3ca442(w105),
  .v0e28cb(w125)
 );
 v816138 v30330f (
  .vcbab45(w19),
  .v0e28cb(w88),
  .v3ca442(w109)
 );
 vafcca2 v897e28 (
  .vcdb471(w27),
  .v0e7114(w91)
 );
 v2ceaf3 v3df28b (
  .v7a5197(w21),
  .v6d986d(w23),
  .vbc3577(w24),
  .v8f02cb(w55)
 );
 v21cfcc vcc7c27 (
  .v9fb85f(w21)
 );
 v5dee27 va73d2e (
 
 );
 v46dac6 #(
  .vc5c8ea(p22)
 ) v5382c7 (
  .v4e67d2(w23)
 );
 v21cfcc vfe369e (
  .v9fb85f(w25)
 );
 vd087b5 #(
  .v25ca2f(p34),
  .vd799e9(p35)
 ) v97edac (
  .v676da9(w20),
  .vaff438(w24),
  .v11674c(w25),
  .v5e34c1(w26),
  .v872b36(w27),
  .vf898ca(w75)
 );
 v05575f v3a419b (
  .va2bcb5(w81)
 );
 v05575f vad7c02 (
 
 );
 vc6459c v9041c1 (
  .v8caaa5(w28),
  .v19b8dd(w29),
  .v2da441(w30),
  .v05e99b(w31),
  .ve9a78f(w76)
 );
 v441629 va4c2bd (
  .v41eb95(w77),
  .vb2c62c(w89),
  .v69b4d1(w93),
  .vf892a0(w113)
 );
 v99d2a8 v9849bb (
  .vb6cda2(w36),
  .vdefec1(w37),
  .vf892a0(w49),
  .v41eb95(w78),
  .veaee74(w87)
 );
 v3e1356 v40eefb (
  .vd25e4b(w37),
  .v3e30ba(w39),
  .v10ee83(w83),
  .v50d6c6(w111)
 );
 vfbba02 #(
  .v8d305c(p38)
 ) vb52069 (
  .va08a29(w39),
  .v9903a0(w107)
 );
 vb2090f v885480 (
  .vcbab45(w42),
  .v0e28cb(w102),
  .v3ca442(w120)
 );
 v816138 v73fe9e (
  .v0e28cb(w40),
  .v3ca442(w44),
  .vcbab45(w47)
 );
 va3eeb4 vf5fb31 (
  .v5a5458(w41),
  .v26bf15(w99)
 );
 v35f267 v38aad7 (
  .v0e28cb(w41),
  .vcbab45(w43)
 );
 vb2090f v5a4b0c (
  .v0e28cb(w42),
  .v3ca442(w43),
  .vcbab45(w44)
 );
 vb2090f v631411 (
  .vcbab45(w45),
  .v0e28cb(w104),
  .v3ca442(w127)
 );
 vb2090f vedd220 (
  .v3ca442(w45),
  .v0e28cb(w46),
  .vcbab45(w48)
 );
 v816138 v3c4c87 (
  .v0e28cb(w47),
  .v3ca442(w48),
  .vcbab45(w49)
 );
 v5cc6ec v372453 (
  .vc93bbe(w50),
  .vb186da(w51),
  .v50d6c6(w126),
  .v381ebf(w132)
 );
 vb2090f vfcd57d (
  .vcbab45(w51),
  .v3ca442(w131),
  .v0e28cb(w133)
 );
 vb9ce14 vdaea06 (
  .v6a1cbe(w52),
  .v2d03ef(w63),
  .v7114a9(w79),
  .v6a2ebd(w133)
 );
 va84e43 #(
  .vb36a78(p5)
 ) vf54750 (
  .v851180(w1),
  .vfde47f(w53)
 );
 v26f57a v08cf01 (
  .v0e9841(w14),
  .vad1323(w53),
  .vf774e8(w54)
 );
 vbc6704 ve5bccb (
  .v595263(w54),
  .v8f149e(w109),
  .v7c37b3(w113),
  .v45ab8c(w114),
  .vb85197(w115),
  .vc85478(w118),
  .ve0c1b4(w120),
  .v7ada3f(w126),
  .v2c9812(w127)
 );
 ve605e8 v89d47a (
  .v516280(w55),
  .v5f8230(w56),
  .v6fb6f4(w98),
  .v50d6c6(w118)
 );
 va2b61a v84665f (
  .vbd782f(w56),
  .vc3e933(w57),
  .v385b9c(w58),
  .vd34531(w67)
 );
 v21cfcc vacba5f (
  .v9fb85f(w57)
 );
 v3bf99b vabb2fd (
  .vb096dc(w58)
 );
 vafcca2 v77e307 (
  .vcdb471(w59)
 );
 va3eeb4 v7b9779 (
  .v0e9841(w61),
  .v26bf15(w116)
 );
 v89d234 ve3dbc1 (
  .vf892a0(w60),
  .v39f831(w61),
  .v41eb95(w80)
 );
 v17838f #(
  .vb36a78(p65)
 ) vc2da39 (
  .v851180(w64),
  .vfde47f(w124)
 );
 vc80943 v9b893a (
  .v595263(w63),
  .v1ec852(w64)
 );
 vf5eca7 vc8bf0d (
  .v7b01cb(w66),
  .v869a97(w67),
  .v363e72(w124)
 );
 vecef7f v363639 (
  .va66214(w66)
 );
endmodule

module v2107ac (
 input vbbbce8,
 input vd9601b,
 output v157a67,
 output v64879c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = vd9601b;
 assign v64879c = w1;
 assign w2 = vbbbce8;
 assign v157a67 = w3;
 v2107ac_v297cb2 v297cb2 (
  .d(w0),
  .tic(w1),
  .clk(w2),
  .state(w3)
 );
endmodule

module v2107ac_v297cb2 (
 input clk,
 input d,
 output state,
 output tic
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d2;
 reg r_in;
 
 always @(posedge clk)
  d2 <= d;
  
 always @(posedge clk)
   r_in <= d2;
 
 
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ r_in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= r_in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 //-- Generar tic en flanco de subida del boton
 reg old;
 
 always @(posedge clk)
   old <= btn_out_r;
   
 assign tic = !old & btn_out_r;
 
 //-- El estado del pulsador se saca por state
 assign state = btn_out_r;
 
 
endmodule

module ve79148 #(
 parameter v5e4a03 = 4
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [1:0] vd76104,
 output v712cd1
);
 localparam p2 = v5e4a03;
 wire [0:1] w0;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 assign vd76104 = w0;
 assign w1 = ve61673;
 assign w3 = v7c533e;
 assign w4 = vdd729a;
 assign v712cd1 = w5;
 ve79148_vbd6086 #(
  .M(p2)
 ) vbd6086 (
  .q(w0),
  .rst(w1),
  .cnt(w3),
  .clk(w4),
  .ov(w5)
 );
endmodule

module ve79148_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [1:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 2; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule

module ve216c9 (
 input [4:0] vd2cdbd,
 input [1:0] v4566f6,
 output [6:0] v1a0366
);
 wire [0:6] w0;
 wire [0:1] w1;
 wire [0:4] w2;
 assign v1a0366 = w0;
 assign w1 = v4566f6;
 assign w2 = vd2cdbd;
 ve216c9_v9a2a06 v9a2a06 (
  .o(w0),
  .i0(w1),
  .i1(w2)
 );
endmodule

module ve216c9_v9a2a06 (
 input [4:0] i1,
 input [1:0] i0,
 output [6:0] o
);
 assign o = {i1, i0};
 
endmodule

module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule

module v5fb041 (
 input [16:0] v26bf15,
 output [4:0] vf72a5a,
 output v5a5458,
 output [9:0] va470fb,
 output v85085c
);
 wire [0:16] w0;
 wire w1;
 wire [0:9] w2;
 wire w3;
 wire [0:4] w4;
 assign w0 = v26bf15;
 assign v85085c = w1;
 assign va470fb = w2;
 assign v5a5458 = w3;
 assign vf72a5a = w4;
 v5fb041_v9a2a06 v9a2a06 (
  .i(w0),
  .len(w1),
  .addr(w2),
  .r(w3),
  .op(w4)
 );
endmodule

module v5fb041_v9a2a06 (
 input [16:0] i,
 output [4:0] op,
 output r,
 output [9:0] addr,
 output len
);
 assign op = i[16:12];
 assign r = i[11];
 assign addr = i[10:1];
 assign len = i[0];
endmodule

module vf7a5f1 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input ve1f7e8,
 input [16:0] va943c0,
 input vf892a0,
 output [16:0] v67d667
);
 localparam p0 = v422d28;
 wire w1;
 wire w2;
 wire w3;
 wire [0:16] w4;
 wire [0:16] w5;
 assign w1 = vf892a0;
 assign w2 = v41eb95;
 assign w3 = ve1f7e8;
 assign v67d667 = w4;
 assign w5 = va943c0;
 vf7a5f1_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .load(w1),
  .clk(w2),
  .rst(w3),
  .q(w4),
  .d(w5)
 );
endmodule

module vf7a5f1_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [16:0] d,
 input load,
 output [16:0] q
);
 localparam N = 17;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (rst)
     q <= 0;
   else if (load)
       q <= d;
endmodule

module v3e1356 (
 input [9:0] v3e30ba,
 input [9:0] v10ee83,
 input v50d6c6,
 output [9:0] vd25e4b
);
 wire w0;
 wire [0:9] w1;
 wire [0:9] w2;
 wire [0:9] w3;
 assign w0 = v50d6c6;
 assign vd25e4b = w1;
 assign w2 = v3e30ba;
 assign w3 = v10ee83;
 v3e1356_ve4e0df ve4e0df (
  .sel(w0),
  .o(w1),
  .i1(w2),
  .i0(w3)
 );
endmodule

module v3e1356_ve4e0df (
 input [9:0] i1,
 input [9:0] i0,
 input sel,
 output [9:0] o
);
 
 reg [9:0] o;
 
 always @(*) begin
     case(sel)
         0: o = i0;
         1: o = i1;
         default: o = i0;
     endcase
 end
 
 
endmodule

module vbc6704 (
 input [7:0] v595263,
 output vc85478,
 output v7ada3f,
 output v2c9812,
 output ve0c1b4,
 output v7c37b3,
 output v8f149e,
 output vb85197,
 output v45ab8c
);
 wire [0:7] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 assign w0 = v595263;
 assign vc85478 = w1;
 assign v7ada3f = w2;
 assign v2c9812 = w3;
 assign ve0c1b4 = w4;
 assign v7c37b3 = w5;
 assign v8f149e = w6;
 assign vb85197 = w7;
 assign v45ab8c = w8;
 vbc6704_v9a2a06 v9a2a06 (
  .i(w0),
  .o7(w1),
  .o6(w2),
  .o5(w3),
  .o4(w4),
  .o3(w5),
  .o2(w6),
  .o1(w7),
  .o0(w8)
 );
endmodule

module vbc6704_v9a2a06 (
 input [7:0] i,
 output o7,
 output o6,
 output o5,
 output o4,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign o7 = i[7];
 assign o6 = i[6];
 assign o5 = i[5];
 assign o4 = i[4];
 assign o3 = i[3];
 assign o2 = i[2];
 assign o1 = i[1];
 assign o0 = i[0];
endmodule

module v5cc6ec (
 input vb186da,
 input v381ebf,
 input v50d6c6,
 output vc93bbe
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v50d6c6;
 assign vc93bbe = w1;
 assign w2 = v381ebf;
 assign w3 = vb186da;
 v5cc6ec_ve4e0df ve4e0df (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

module v5cc6ec_ve4e0df (
 input i1,
 input i0,
 input sel,
 output o
);
 //-- Multiplexor de 2 a 1, 
 //-- de 8 bits
 
 reg _o;
 
 always @(*) begin
     case(sel)
         0: _o = i0;
         1: _o = i1;
         default: _o = i0;
     endcase
 end
 
 assign o = _o;
 
endmodule

module v816138 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v816138_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module v816138_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a | b;
 
 //-- endmodule
endmodule

module v3db97e #(
 parameter v55b764 = 1
) (
 input v4c8225,
 output v6d0651
);
 localparam p1 = v55b764;
 wire w0;
 wire w2;
 wire w3;
 wire [0:5] w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 assign v6d0651 = w6;
 assign w7 = v4c8225;
 assign w8 = v4c8225;
 assign w9 = v4c8225;
 assign w3 = w2;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 vb959c2 #(
  .v679341(p1)
 ) vd55cad (
  .vb4c770(w0),
  .v3c6908(w3),
  .ve68648(w5),
  .v581b48(w8)
 );
 v21cfcc v3023dc (
  .v9fb85f(w5)
 );
 v8e2728 v50467e (
  .v10eedb(w2),
  .v2dffca(w6),
  .v0884a0(w7)
 );
 v2814a1 vf701ed (
  .vc7a3dc(w2),
  .v1c1141(w4)
 );
 vc89ab7 vff7be6 (
  .v65c173(w0),
  .v15fb32(w4),
  .vdd729a(w9)
 );
endmodule

module vb959c2 #(
 parameter v679341 = 0
) (
 input v581b48,
 input ve68648,
 input v3c6908,
 output vb4c770
);
 localparam p4 = v679341;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v581b48;
 assign w1 = ve68648;
 assign w2 = v3c6908;
 assign vb4c770 = w3;
 vb959c2_v4e11b3 #(
  .INI(p4)
 ) v4e11b3 (
  .clk(w0),
  .set(w1),
  .rst(w2),
  .q(w3)
 );
endmodule

module vb959c2_v4e11b3 #(
 parameter INI = 0
) (
 input clk,
 input set,
 input rst,
 output q
);
 reg q = INI;
 
 always @(posedge clk)
   if (set)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
endmodule

module v21cfcc (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v21cfcc_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

module v21cfcc_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule

module v8e2728 (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v8e2728_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

module v8e2728_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (~q & i);  
endmodule

module v2814a1 (
 input [5:0] v1c1141,
 output vc7a3dc,
 output [4:0] vaa52cb
);
 wire [0:5] w0;
 wire [0:4] w1;
 wire w2;
 assign w0 = v1c1141;
 assign vaa52cb = w1;
 assign vc7a3dc = w2;
 v2814a1_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

module v2814a1_v9a2a06 (
 input [5:0] i,
 output o1,
 output [4:0] o0
);
 assign o1 = i[5];
 assign o0 = i[4:0];
 
endmodule

module vc89ab7 (
 input vdd729a,
 input v65c173,
 output [5:0] v15fb32
);
 wire w0;
 wire [0:5] w1;
 wire w2;
 assign w0 = vdd729a;
 assign v15fb32 = w1;
 assign w2 = v65c173;
 vc89ab7_ve444b7 ve444b7 (
  .clk(w0),
  .q(w1),
  .ena(w2)
 );
endmodule

module vc89ab7_ve444b7 (
 input clk,
 input ena,
 output [5:0] q
);
 reg [5:0] q;
 
 always @(posedge clk)
 begin
   if (ena)
     q <= q + 1;
 end
endmodule

module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule

module v4afab0 #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [4:0] v851180,
 output [7:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:4] w1;
 wire [0:7] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 v4afab0_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

module v4afab0_v361fe9 #(
 parameter DATA = 0
) (
 input [4:0] i,
 output [7:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 5;
 
 //-- Bits del bus de salida
 localparam M = 8;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemh(DATA, tabla);
 end
endmodule

module v441629 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input vb2c62c,
 input [16:0] v69b4d1,
 input vf892a0,
 output [16:0] v787077
);
 localparam p0 = v422d28;
 wire w1;
 wire w2;
 wire w3;
 wire [0:16] w4;
 wire [0:16] w5;
 assign w1 = vf892a0;
 assign w2 = v41eb95;
 assign w3 = vb2c62c;
 assign w4 = v69b4d1;
 assign v787077 = w5;
 v441629_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .load(w1),
  .clk(w2),
  .rst(w3),
  .d(w4),
  .q(w5)
 );
endmodule

module v441629_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [16:0] d,
 input load,
 output [16:0] q
);
 localparam N = 17;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (rst)
     q <= INI;
   else
     if (load)
       q <= d;
endmodule

module v3369ab (
 input [16:0] vcedc5d,
 input [16:0] va79ab3,
 output [16:0] v02a59a
);
 wire [0:16] w0;
 wire [0:16] w1;
 wire [0:16] w2;
 assign v02a59a = w0;
 assign w1 = va79ab3;
 assign w2 = vcedc5d;
 v3369ab_va0c26a va0c26a (
  .s(w0),
  .b(w1),
  .a(w2)
 );
endmodule

module v3369ab_va0c26a (
 input [16:0] a,
 input [16:0] b,
 output [16:0] s
);
 assign s = a + b;
endmodule

module ve605e8 (
 input [16:0] v5f8230,
 input [16:0] v6fb6f4,
 input v50d6c6,
 output [16:0] v516280
);
 wire w0;
 wire [0:16] w1;
 wire [0:16] w2;
 wire [0:16] w3;
 assign w0 = v50d6c6;
 assign v516280 = w1;
 assign w2 = v6fb6f4;
 assign w3 = v5f8230;
 ve605e8_ve4e0df ve4e0df (
  .sel(w0),
  .o(w1),
  .i0(w2),
  .i1(w3)
 );
endmodule

module ve605e8_ve4e0df (
 input [16:0] i1,
 input [16:0] i0,
 input sel,
 output [16:0] o
);
 //-- Multiplexor de 2 a 1, 
 //-- de 17 bits
 
 reg [16:0] o;
 
 always @(*) begin
     case(sel)
         0: o = i0;
         1: o = i1;
         default: o = i0;
     endcase
 end
 
 
endmodule

module va3eeb4 (
 input [16:0] v26bf15,
 output v5a5458,
 output [7:0] vf774e8,
 output [7:0] v0e9841
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:16] w2;
 wire w3;
 assign v0e9841 = w0;
 assign vf774e8 = w1;
 assign w2 = v26bf15;
 assign v5a5458 = w3;
 va3eeb4_v9a2a06 v9a2a06 (
  .o0(w0),
  .o1(w1),
  .i(w2),
  .o2(w3)
 );
endmodule

module va3eeb4_v9a2a06 (
 input [16:0] i,
 output o2,
 output [7:0] o1,
 output [7:0] o0
);
 assign o2 = i[16];
 assign o1 = i[15:8];
 assign o0 = i[7:0];
endmodule

module v43b132 (
 input [7:0] v595263,
 output [4:0] vdb0277,
 output [2:0] v738343
);
 wire [0:7] w0;
 wire [0:2] w1;
 wire [0:4] w2;
 assign w0 = v595263;
 assign v738343 = w1;
 assign vdb0277 = w2;
 v43b132_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2)
 );
endmodule

module v43b132_v9a2a06 (
 input [7:0] i,
 output [4:0] o1,
 output [2:0] o0
);
 assign o1 = i[7:3];
 assign o0 = i[2:0];
endmodule

module v42ebf7 #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 input v9afc1f,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 wire w4;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 assign w4 = v9afc1f;
 v42ebf7_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3),
  .load(w4)
 );
endmodule

module v42ebf7_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 input load,
 output q
);
 reg q = INI;
 always @(posedge clk)
   if (load)
     q <= d;
endmodule

module vafcca2 (
 input [34:0] vcdb471,
 output [16:0] v0e7114,
 output v1a8a46,
 output [16:0] v2b864c
);
 wire [0:34] w0;
 wire [0:16] w1;
 wire w2;
 wire [0:16] w3;
 assign w0 = vcdb471;
 assign v2b864c = w1;
 assign v1a8a46 = w2;
 assign v0e7114 = w3;
 vafcca2_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2),
  .o2(w3)
 );
endmodule

module vafcca2_v9a2a06 (
 input [34:0] i,
 output [16:0] o2,
 output o1,
 output [16:0] o0
);
 assign o2 = i[34:18];
 assign o1 = i[17];
 assign o0 = i[16:0];
endmodule

module v2ceaf3 (
 input [16:0] v8f02cb,
 input v7a5197,
 input [16:0] v6d986d,
 output [34:0] vbc3577
);
 wire w0;
 wire [0:34] w1;
 wire [0:16] w2;
 wire [0:16] w3;
 assign w0 = v7a5197;
 assign vbc3577 = w1;
 assign w2 = v6d986d;
 assign w3 = v8f02cb;
 v2ceaf3_v9a2a06 v9a2a06 (
  .i1(w0),
  .o(w1),
  .i0(w2),
  .i2(w3)
 );
endmodule

module v2ceaf3_v9a2a06 (
 input [16:0] i2,
 input i1,
 input [16:0] i0,
 output [34:0] o
);
 assign o = {i2, i1, i0};
 
endmodule

module v5dee27 #(
 parameter vfffc23 = 0
) (
 output [16:0] vc144ff
);
 localparam p0 = vfffc23;
 v34688e #(
  .vc5c8ea(p0)
 ) v46a5dd (
 
 );
endmodule

module v34688e #(
 parameter vc5c8ea = 0
) (
 output [15:0] v366f99
);
 localparam p0 = vc5c8ea;
 wire [0:15] w1;
 assign v366f99 = w1;
 v34688e_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

module v34688e_v465065 #(
 parameter VALUE = 0
) (
 output [15:0] k
);
 assign k = VALUE;
endmodule

module v46dac6 #(
 parameter vc5c8ea = 0
) (
 output [16:0] v4e67d2
);
 localparam p0 = vc5c8ea;
 wire [0:16] w1;
 assign v4e67d2 = w1;
 v46dac6_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

module v46dac6_v465065 #(
 parameter VALUE = 0
) (
 output [16:0] k
);
 assign k = VALUE;
endmodule

module vd087b5 #(
 parameter vd799e9 = "vd799e9.list",
 parameter v7ab4d1 = "v7ab4d1.list",
 parameter v25ca2f = "v25ca2f.list"
) (
 input vf898ca,
 input [9:0] v676da9,
 input [34:0] vaff438,
 input v11674c,
 input v5e34c1,
 output [34:0] v872b36
);
 localparam p0 = vd799e9;
 localparam p1 = v25ca2f;
 localparam p2 = v7ab4d1;
 wire [0:16] w3;
 wire w4;
 wire w5;
 wire [0:16] w6;
 wire [0:16] w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:9] w11;
 wire [0:34] w12;
 wire [0:8] w13;
 wire [0:8] w14;
 wire [0:8] w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:16] w22;
 wire [0:16] w23;
 wire [0:16] w24;
 wire w25;
 wire [0:16] w26;
 wire [0:16] w27;
 wire [0:16] w28;
 wire [0:16] w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire [0:34] w42;
 assign w8 = vf898ca;
 assign w9 = vf898ca;
 assign w10 = vf898ca;
 assign w11 = v676da9;
 assign w12 = vaff438;
 assign w16 = v11674c;
 assign w17 = v11674c;
 assign w18 = v11674c;
 assign w19 = v11674c;
 assign w20 = v5e34c1;
 assign w21 = v5e34c1;
 assign v872b36 = w42;
 assign w9 = w8;
 assign w10 = w8;
 assign w10 = w9;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 assign w17 = w16;
 assign w18 = w16;
 assign w18 = w17;
 assign w19 = w16;
 assign w19 = w17;
 assign w19 = w18;
 assign w21 = w20;
 assign w23 = w22;
 assign w27 = w26;
 assign w29 = w28;
 assign w34 = w33;
 assign w35 = w33;
 assign w35 = w34;
 assign w37 = w36;
 assign w39 = w38;
 vbd4e22 #(
  .v5a4ee6(p0)
 ) vf90cf7 (
  .v922e3d(w9),
  .vdfe2a0(w14),
  .vcfb944(w22),
  .vbeef66(w28),
  .v23dc54(w31)
 );
 vbd4e22 #(
  .v5a4ee6(p1)
 ) vddb750 (
  .vbeef66(w3),
  .v922e3d(w8),
  .vdfe2a0(w13),
  .vcfb944(w26),
  .v23dc54(w32)
 );
 v925a64 #(
  .v5a4ee6(p2)
 ) vb5565a (
  .v922e3d(w10),
  .v0cabc9(w15),
  .v8c619a(w25),
  .v12a8ab(w30),
  .v23dc54(w33)
 );
 v01b4d9 v664388 (
  .va2bcb5(w11),
  .v36beea(w13),
  .v53acca(w36)
 );
 v305b08 vbf0d67 (
  .vcdb471(w12),
  .v2b864c(w24),
  .v0e7114(w28),
  .v1a8a46(w30)
 );
 ve605e8 vc68eaa (
  .v516280(w3),
  .v50d6c6(w16),
  .v5f8230(w24),
  .v6fb6f4(w29)
 );
 ve108d0 v0b7f6f (
  .v0e9572(w21),
  .vaf813b(w37),
  .v5399d1(w40),
  .v8f3bff(w41)
 );
 v816138 v1a049e (
  .v3ca442(w4),
  .vcbab45(w31),
  .v0e28cb(w35)
 );
 v816138 vcd3019 (
  .v3ca442(w5),
  .vcbab45(w32),
  .v0e28cb(w34)
 );
 vb2090f vf5a001 (
  .v3ca442(w18),
  .v0e28cb(w20),
  .vcbab45(w33)
 );
 vb2090f v736de3 (
  .vcbab45(w4),
  .v0e28cb(w39),
  .v3ca442(w41)
 );
 vb2090f v9a1e37 (
  .vcbab45(w5),
  .v0e28cb(w38),
  .v3ca442(w40)
 );
 v35f267 v8c5475 (
  .v0e28cb(w19),
  .vcbab45(w38)
 );
 v835693 v4faef0 (
  .v8f02cb(w6),
  .v7a5197(w25),
  .v6d986d(w27),
  .vbc3577(w42)
 );
 ve605e8 vcc96b3 (
  .v516280(w6),
  .v6fb6f4(w7),
  .v50d6c6(w17),
  .v5f8230(w22)
 );
 ve605e8 v32391a (
  .v516280(w7),
  .v5f8230(w23),
  .v6fb6f4(w26),
  .v50d6c6(w36)
 );
endmodule

module vbd4e22 #(
 parameter v5a4ee6 = "v5a4ee6.list"
) (
 input v922e3d,
 input [8:0] vdfe2a0,
 input [16:0] vbeef66,
 input v23dc54,
 output [16:0] vcfb944
);
 localparam p2 = v5a4ee6;
 wire w0;
 wire w1;
 wire [0:16] w3;
 wire [0:16] w4;
 wire [0:8] w5;
 assign w0 = v922e3d;
 assign w1 = v23dc54;
 assign w3 = vbeef66;
 assign vcfb944 = w4;
 assign w5 = vdfe2a0;
 vbd4e22_vbaa912 #(
  .ROMF(p2)
 ) vbaa912 (
  .clk(w0),
  .wr(w1),
  .data_in(w3),
  .data_out(w4),
  .addr(w5)
 );
endmodule

module vbd4e22_vbaa912 #(
 parameter ROMF = 0
) (
 input clk,
 input [8:0] addr,
 input [16:0] data_in,
 input wr,
 output [16:0] data_out
);
 //-- Address with
 localparam ADDR_WIDTH = 9;
 //-- Data with
 localparam DATA_WIDTH = 17;
 
 //-- Size of the memory
 localparam SIZE = 1 << ADDR_WIDTH;
 
 //-- Memory itself
 reg [DATA_WIDTH-1:0] mem[0:SIZE-1];
 
 //-- The data_out is a registered output (not a wire)
 reg data_out;
 
 //-- Reading port: Synchronous
 always @(posedge clk)
 begin
   data_out <= mem[addr];
 end
 
 //-- Writing port: Synchronous
 always @(posedge clk)
 begin
     if (wr) mem[addr] <= data_in;
 end
 
 
 //-- Init the memory
 initial begin
   
   if (ROMF)
     $readmemb(ROMF, mem, 0, SIZE-1);
   
 end
 
endmodule

module v925a64 #(
 parameter v5a4ee6 = "v5a4ee6.list"
) (
 input v922e3d,
 input [8:0] v0cabc9,
 input v12a8ab,
 input v23dc54,
 output v8c619a
);
 localparam p2 = v5a4ee6;
 wire w0;
 wire w1;
 wire [0:8] w3;
 wire w4;
 wire w5;
 assign w0 = v922e3d;
 assign w1 = v23dc54;
 assign w3 = v0cabc9;
 assign w4 = v12a8ab;
 assign v8c619a = w5;
 v925a64_vbaa912 #(
  .ROMF(p2)
 ) vbaa912 (
  .clk(w0),
  .wr(w1),
  .addr(w3),
  .data_in(w4),
  .data_out(w5)
 );
endmodule

module v925a64_vbaa912 #(
 parameter ROMF = 0
) (
 input clk,
 input [8:0] addr,
 input data_in,
 input wr,
 output data_out
);
 //-- Address with
 localparam ADDR_WIDTH = 9;
 //-- Data with
 localparam DATA_WIDTH = 1;
 
 //-- Size of the memory
 localparam SIZE = 1 << ADDR_WIDTH;
 
 //-- Memory itself
 reg [DATA_WIDTH-1:0] mem[0:SIZE-1];
 
 //-- The data_out is a registered output (not a wire)
 reg data_out;
 
 //-- Reading port: Synchronous
 always @(posedge clk)
 begin
   data_out <= mem[addr];
 end
 
 //-- Writing port: Synchronous
 always @(posedge clk)
 begin
     if (wr) mem[addr] <= data_in;
 end
 
 
 //-- Init the memory
 initial begin
   
   if (ROMF)
     $readmemb(ROMF, mem, 0, SIZE-1);
   
 end
 
endmodule

module v01b4d9 (
 input [9:0] va2bcb5,
 output [8:0] v36beea,
 output v53acca
);
 wire [0:9] w0;
 wire [0:8] w1;
 wire w2;
 assign w0 = va2bcb5;
 assign v36beea = w1;
 assign v53acca = w2;
 v01b4d9_v9a2a06 v9a2a06 (
  .i(w0),
  .o1(w1),
  .o0(w2)
 );
endmodule

module v01b4d9_v9a2a06 (
 input [9:0] i,
 output [8:0] o1,
 output o0
);
 assign o1 = i[9:1];
 assign o0 = i[0];
endmodule

module v305b08 (
 input [34:0] vcdb471,
 output [16:0] v0e7114,
 output v1a8a46,
 output [16:0] v2b864c
);
 wire [0:34] w0;
 wire [0:16] w1;
 wire w2;
 wire [0:16] w3;
 assign w0 = vcdb471;
 assign v2b864c = w1;
 assign v1a8a46 = w2;
 assign v0e7114 = w3;
 v305b08_v9a2a06 v9a2a06 (
  .i(w0),
  .o0(w1),
  .o1(w2),
  .o2(w3)
 );
endmodule

module v305b08_v9a2a06 (
 input [34:0] i,
 output [16:0] o2,
 output o1,
 output [16:0] o0
);
 assign o2 = i[34:18];
 assign o1 = i[17];
 assign o0 = i[16:0];
endmodule

module ve108d0 (
 input v0e9572,
 input vaf813b,
 output v8f3bff,
 output v5399d1
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign v8f3bff = w0;
 assign v5399d1 = w1;
 assign w2 = vaf813b;
 assign w3 = v0e9572;
 ve108d0_v45bd49 v45bd49 (
  .o1(w0),
  .o0(w1),
  .sel(w2),
  .i(w3)
 );
endmodule

module ve108d0_v45bd49 (
 input i,
 input sel,
 output o1,
 output o0
);
 assign {o1,o0} = i << sel;
 
endmodule

module v835693 (
 input [16:0] v8f02cb,
 input v7a5197,
 input [16:0] v6d986d,
 output [34:0] vbc3577
);
 wire w0;
 wire [0:34] w1;
 wire [0:16] w2;
 wire [0:16] w3;
 assign w0 = v7a5197;
 assign vbc3577 = w1;
 assign w2 = v6d986d;
 assign w3 = v8f02cb;
 v835693_v9a2a06 v9a2a06 (
  .i1(w0),
  .o(w1),
  .i0(w2),
  .i2(w3)
 );
endmodule

module v835693_v9a2a06 (
 input [16:0] i2,
 input i1,
 input [16:0] i0,
 output [34:0] o
);
 assign o = {i2, i1, i0};
 
endmodule

module v05575f (
 input [9:0] va2bcb5,
 output [7:0] ve6d4ad,
 output [1:0] vba28de
);
 wire [0:7] w0;
 wire [0:1] w1;
 wire [0:9] w2;
 assign ve6d4ad = w0;
 assign vba28de = w1;
 assign w2 = va2bcb5;
 v05575f_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

module v05575f_v9a2a06 (
 input [9:0] i,
 output [7:0] o1,
 output [1:0] o0
);
 assign o1 = i[9:2];
 assign o0 = i[1:0];
endmodule

module vc6459c #(
 parameter ved2ada = 115200
) (
 input ve9a78f,
 input [7:0] v19b8dd,
 input v05e99b,
 output v8caaa5,
 output v2da441,
 output v01321e
);
 localparam p1 = ved2ada;
 wire w0;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 assign v8caaa5 = w0;
 assign w2 = ve9a78f;
 assign w3 = v19b8dd;
 assign w4 = v05e99b;
 assign v2da441 = w5;
 assign v01321e = w6;
 vc6459c_vedebcc #(
  .BAUD(p1)
 ) vedebcc (
  .TX(w0),
  .clk(w2),
  .data(w3),
  .txmit(w4),
  .busy(w5),
  .done(w6)
 );
endmodule

module vc6459c_vedebcc #(
 parameter BAUD = 0
) (
 input clk,
 input [7:0] data,
 input txmit,
 output TX,
 output busy,
 output done
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 //---- GENERADOR DE BAUDIOS
 
 //-- Calcular el numero dde bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 //-- Comparador que resetea el contador cuando se alcanza el tope
 //-- o cuando el estado del biestable es 0 (apagado)
 wire reset = ov_gen | (state == 0);
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Hemos llegado al final
 wire ov_gen = (divcounter == BAUDRATE-1);
 
 
 
 //-- REGISTRO DESPLAZAMIENTO
 
 //-- Salida serie. Inicialmete a 1 (reposo) 
 reg TX = 1;
 
 //-- Registro de desplazamiento de 9 bits
 //-- Inicializado todo a 1s
 reg [8:0] q = 9'h1FF;
 
 //-- La entrada de shift es la salida del generador de baudios
 wire shift = ov_gen;
 
 always @(posedge clk)
   if (txmit_tic)
   //-- Carga del registro
     q <= {data, 1'b0};
     
   else if (shift)
     //-- Desplazamiento. Rellenar con 1 (bit de stop)
     q <= {1'b1, q[8:1]};
     
 //-- Sacar el bit de menor peso por serial-out    
 wire so;
 assign so = q[0];
 
 //-- La salida tx la registramos
 always @(posedge clk)
   TX <= so;
   
 //-- La señal de entrada txmit se pasa por un 
 //-- detector de flancos de subida para generar un tic
 reg q_re = 0;
 wire txmit_tic;
 
 always @(posedge clk)
   q_re <= txmit;
   
 assign txmit_tic = (~q_re & txmit);  
 
 
 
 //-- Estado de transmisor
 //-- 0: Parado
 //-- 1: Ocupado (transmitiendo)
 reg state = 0;
   
 always @(posedge clk)
   //-- Empieza la transmision: ocupado
   if (txmit)
     state <= 1'b1;
     
   //-- Acaba la transmision: libre    
   else if (ov)
     state <= 1'b0;
 
 //-- Contador de bits enviados
 reg [3:0] bits = 0;
 always @(posedge clk)
   //-- Si la cuenta ha terminado... volver a 0
   if (ov)
     bits <= 2'b00;
   else
     if (shift)
       bits <= bits + 1;
 
 //-- Comprobar si se ha transmitido el último bit (overflow)
 //-- 1 bit de start + 8 bits de datos + 1 bit de stop
 wire ov = (bits == 10);
 
 //-- La señal de ocupado es el estado del transmisor
 assign busy = state;
 
 //-- La señal de done es la de overflow pero retrasada un
 //-- periodo de reloj del sistema y que el biestable 
 //-- llegue al estado de parado antes de que se 
 //-- empiece otra transmision
 
 reg done=0;
 
 always @(posedge clk)
   done <= ov;
 
endmodule

module v99d2a8 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input veaee74,
 input [9:0] vdefec1,
 input vf892a0,
 output [9:0] vb6cda2
);
 localparam p0 = v422d28;
 wire w1;
 wire w2;
 wire w3;
 wire [0:9] w4;
 wire [0:9] w5;
 assign w1 = vf892a0;
 assign w2 = v41eb95;
 assign w3 = veaee74;
 assign w4 = vdefec1;
 assign vb6cda2 = w5;
 v99d2a8_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .load(w1),
  .clk(w2),
  .rst(w3),
  .d(w4),
  .q(w5)
 );
endmodule

module v99d2a8_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input rst,
 input [9:0] d,
 input load,
 output [9:0] q
);
 localparam N = 10;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (rst)
     q <= 0;
   else
     if (load)
       q <= d;
endmodule

module vfbba02 #(
 parameter v8d305c = 1
) (
 input [9:0] v9903a0,
 output [9:0] va08a29
);
 localparam p0 = v8d305c;
 wire [0:9] w1;
 wire [0:9] w2;
 assign w1 = v9903a0;
 assign va08a29 = w2;
 vfbba02_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

module vfbba02_va0c26a #(
 parameter k = 0
) (
 input [9:0] a,
 output [9:0] s
);
 assign s = a + k;
endmodule

module vb9ce14 #(
 parameter v47d474 = 115200
) (
 input v7114a9,
 input v6a1cbe,
 output [7:0] v2d03ef,
 output ve77bd8,
 output v6a2ebd
);
 localparam p4 = v47d474;
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w5;
 assign w0 = v7114a9;
 assign w1 = v6a1cbe;
 assign v2d03ef = w2;
 assign v6a2ebd = w3;
 assign ve77bd8 = w5;
 vb9ce14_vf55761 #(
  .BAUD(p4)
 ) vf55761 (
  .clk(w0),
  .RX(w1),
  .data(w2),
  .rcv(w3),
  .busy(w5)
 );
endmodule

module vb9ce14_vf55761 #(
 parameter BAUD = 0
) (
 input clk,
 input RX,
 output [7:0] data,
 output busy,
 output rcv
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 
 
 //-- Calcular el numero de bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d1;
 reg din;
 
 always @(posedge clk)
  d1 <= RX;
  
 //-- Din contiene el dato serie de entrada listo para usarse   
 always @(posedge clk)
   din <= d1;
   
 //------ Detectar el bit de start: flanco de bajada en din
 
 //-- Registro temporal
 reg q_t0 = 0;
 
 always @(posedge clk)
   q_t0 <= din;
   
 //-- El cable din_fe es un "tic" que aparece cuando llega el flanco de 
 //-- bajada
 wire din_fe = (q_t0 & ~din);
 
 //-------- ESTADO DEL RECEPTOR
 
 //-- 0: Apagado. Esperando
 //-- 1: Encendido. Activo. Recibiendo dato
 reg state = 0;
 
 always @(posedge clk)
   //-- Se pasa al estado activo al detectar el flanco de bajada
   //-- del bit de start
   if (din_fe)
     state <= 1'b1;
     
   //-- Se pasa al estado inactivo al detectar la señal rst_state    
   else if (rst_state)
     state<=1'b0;
 
 //------------------ GENERADOR DE BAUDIOS -----------------------------
 //-- Se activa cuando el receptor está encendido
 
 
 //-- Calcular la mitad del divisor BAUDRATE/2
 localparam BAUD2 = (BAUDRATE >> 1);
 
 //-- Contador del sistema, para esperar un tiempo de  
 //-- medio bit (BAUD2)
 
 //-- NOTA: podria tener N-2 bits en principio
 reg [N-1: 0] div2counter = 0;
 
 //-- Se genera primero un retraso de BAUD/2
 //-- El proceso comienza cuando el estado pasa a 1
 
 always @(posedge clk)
 
   //-- Contar
   if (state) begin
     //-- Solo cuenta hasta BAUD2, luego  
     //-- se queda en ese valor hasta que
     //-- ena se desactiva
     if (div2counter < BAUD2) 
       div2counter <= div2counter + 1;
   end else
     div2counter <= 0;
 
 //-- Habilitar el generador de baudios principal
 //-- cuando termine este primer contador
 wire ena2 = (div2counter == BAUD2);
 
 
 //------ GENERADOR DE BAUDIOS PRINCIPAL
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Esta señal contiene el tic
 wire ov = (divcounter == BAUDRATE-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena2 == 0);
 
 //-- El cable con el tic para capturar cada bit lo llamamos
 //-- bit_tic, y es la señal de overflow del contador
 wire bit_tic = ov;
 
 //-------- REGISTRO DE DESPLAZAMIENTO -----------
 //-- Es el componente que pasa los bits recibidos a paralelo
 //-- La señal de desplazamiento usada es bit_tic, pero sólo cuando  
 //-- estamos en estado de encendido (state==1)
 //-- Es un registro de 9 bits: 8 bits de datos + bit de stop
 //-- El bit de start no se almacena, es el que ha servido para
 //-- arrancar el receptor
 
 reg [8:0] sr = 0;
 
 always @(posedge clk)
   //-- Se captura el bit cuando llega y el receptor
   //-- esta activado
   if (bit_tic & state)
     sr <= {din, sr[8:1]};
     
 //-- El dato recibido se encuentran en los 8 bits menos significativos
 //-- una vez recibidos los 9 bits
 
 //-------- CONTADOR de bits recibidos
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [4:0] cont = 0;
 
 always @(posedge clk)
 
   //-- El contador se pone a 0 si hay un overflow o 
   //-- el receptor está apagado 
   if ((state==0)| ov2)
     cont <= 0;
   else
     //-- Receptor activado: Si llega un bit se incrementa
     if (bit_tic)
       cont <= cont + 1;
       
 //-- Comprobar overflow
 wire ov2 = (cont == 9);
     
 //-- Esta señal de overflow indica el final de la recepción
 wire fin = ov2;
 
 //-- Se conecta al reset el biestable de estado
 wire rst_state = fin;
 
 //----- REGISTRO DE DATOS -------------------
 //-- Registro de 8 bits que almacena el dato final
 
 //-- Bus de salida con el dato recibido
 reg data = 0;
 
 always @(posedge clk)
 
   //-- Si se ha recibido el ultimo bit, capturamos el dato
   //-- que se encuentra en los 8 bits de menor peso del
   //-- registro de desplazamiento
   if (fin)
     data <= sr[7:0];
 
 //-- Comunicar que se ha recibido un dato
 //-- Tic de dato recibido
 reg rcv = 0;
 always @(posedge clk)
   rcv <= fin;
 
 //-- La señal de busy es directamente el estado del receptor
 assign busy = state;
 
 
endmodule

module va84e43 #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [6:0] v851180,
 output [15:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:6] w1;
 wire [0:15] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 va84e43_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

module va84e43_v361fe9 #(
 parameter DATA = 0
) (
 input [6:0] i,
 output [15:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 7;
 
 //-- Bits del bus de salida
 localparam M = 16;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemb(DATA, tabla);
 end
endmodule

module v26f57a (
 input [15:0] vad1323,
 output [7:0] vf774e8,
 output [7:0] v0e9841
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:15] w2;
 assign v0e9841 = w0;
 assign vf774e8 = w1;
 assign w2 = vad1323;
 v26f57a_v9a2a06 v9a2a06 (
  .o0(w0),
  .o1(w1),
  .i(w2)
 );
endmodule

module v26f57a_v9a2a06 (
 input [15:0] i,
 output [7:0] o1,
 output [7:0] o0
);
 assign o1 = i[15:8];
 assign o0 = i[7:0];
endmodule

module va2b61a (
 input vc3e933,
 input [7:0] v385b9c,
 input [7:0] vd34531,
 output [16:0] vbd782f
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire w2;
 wire [0:16] w3;
 assign w0 = vd34531;
 assign w1 = v385b9c;
 assign w2 = vc3e933;
 assign vbd782f = w3;
 va2b61a_v9a2a06 v9a2a06 (
  .i0(w0),
  .i1(w1),
  .i2(w2),
  .o(w3)
 );
endmodule

module va2b61a_v9a2a06 (
 input i2,
 input [7:0] i1,
 input [7:0] i0,
 output [16:0] o
);
 assign o = {i2, i1, i0};
 
endmodule

module v3bf99b #(
 parameter vfffc23 = 0
) (
 output [7:0] vb096dc
);
 localparam p0 = vfffc23;
 wire [0:7] w1;
 assign vb096dc = w1;
 v5ad97e #(
  .vc5c8ea(p0)
 ) v68b2cc (
  .v26dbdb(w1)
 );
endmodule

module v5ad97e #(
 parameter vc5c8ea = 0
) (
 output [7:0] v26dbdb
);
 localparam p0 = vc5c8ea;
 wire [0:7] w1;
 assign v26dbdb = w1;
 v5ad97e_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

module v5ad97e_v465065 #(
 parameter VALUE = 0
) (
 output [7:0] k
);
 assign k = VALUE;
endmodule

module v89d234 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [7:0] v39f831,
 input vf892a0,
 output [7:0] vb1c024
);
 localparam p0 = v422d28;
 wire [0:7] w1;
 wire [0:7] w2;
 wire w3;
 wire w4;
 assign vb1c024 = w1;
 assign w2 = v39f831;
 assign w3 = vf892a0;
 assign w4 = v41eb95;
 v89d234_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .q(w1),
  .d(w2),
  .load(w3),
  .clk(w4)
 );
endmodule

module v89d234_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
endmodule

module v17838f #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [6:0] v851180,
 output [4:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:6] w1;
 wire [0:4] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 v17838f_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

module v17838f_v361fe9 #(
 parameter DATA = 0
) (
 input [6:0] i,
 output [4:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 7;
 
 //-- Bits del bus de salida
 localparam M = 5;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemh(DATA, tabla);
 end
endmodule

module vc80943 (
 input [7:0] v595263,
 output v57076f,
 output [6:0] v1ec852
);
 wire [0:7] w0;
 wire w1;
 wire [0:6] w2;
 assign w0 = v595263;
 assign v57076f = w1;
 assign v1ec852 = w2;
 vc80943_v9a2a06 v9a2a06 (
  .i(w0),
  .o1(w1),
  .o0(w2)
 );
endmodule

module vc80943_v9a2a06 (
 input [7:0] i,
 output o1,
 output [6:0] o0
);
 assign o1 = i[7];
 assign o0 = i[6:0];
endmodule

module vf5eca7 (
 input [2:0] v7b01cb,
 input [4:0] v363e72,
 output [7:0] v869a97
);
 wire [0:7] w0;
 wire [0:2] w1;
 wire [0:4] w2;
 assign v869a97 = w0;
 assign w1 = v7b01cb;
 assign w2 = v363e72;
 vf5eca7_v9a2a06 v9a2a06 (
  .o(w0),
  .i1(w1),
  .i0(w2)
 );
endmodule

module vf5eca7_v9a2a06 (
 input [2:0] i1,
 input [4:0] i0,
 output [7:0] o
);
 assign o = {i1, i0};
 
endmodule

module vecef7f #(
 parameter vfffc23 = 0
) (
 output [2:0] va66214
);
 localparam p0 = vfffc23;
 wire [0:2] w1;
 assign va66214 = w1;
 vbe878c #(
  .vc5c8ea(p0)
 ) v7f3234 (
  .v8cf592(w1)
 );
endmodule

module vbe878c #(
 parameter vc5c8ea = 0
) (
 output [2:0] v8cf592
);
 localparam p0 = vc5c8ea;
 wire [0:2] w1;
 assign v8cf592 = w1;
 vbe878c_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

module vbe878c_v465065 #(
 parameter VALUE = 0
) (
 output [2:0] k
);
 assign k = VALUE;
endmodule
